# AIstoic プロジェクト分析レポート

## 1. プロジェクト概要

AIstoicは、ポケモン第三世代におけるサンダー対メタグロスの1対1対戦でのサンダー側勝率を計算するWebアプリケーションです。

### 技術スタック
- Vite + React + TypeScript
- Tailwind CSS
- shadcn/ui コンポーネント
- Vitest（テストフレームワーク）

## 2. プロジェクト構造

```
src/
├── App.tsx                     # メインコンポーネント
├── components/                 # UIコンポーネント
│   ├── ThunderForm.tsx        # サンダー設定フォーム
│   ├── CustomMetagrossForm.tsx # カスタムメタグロス設定
│   ├── WinRateTable.tsx       # 勝率表示テーブル
│   ├── DamageCalculation.tsx  # ダメージ計算表示
│   ├── HelpSection.tsx        # ヘルプセクション
│   └── ui/                    # shadcn/ui
├── constants/                  # 定数定義
│   ├── pokemon.ts             # ポケモン関連定数
│   └── items.ts               # 持ち物関連定数
├── types/                      # 型定義
│   └── pokemon.ts             # ポケモン関連の型
├── utils/                      # ユーティリティ関数
│   ├── damage.ts              # ダメージ計算
│   ├── battle.ts              # バトルシミュレーション（550行）
│   ├── simulation.ts          # モンテカルロシミュレーション
│   ├── stats.ts               # ステータス計算
│   ├── evOptimization.ts      # 努力値最適化
│   └── evCalculation.ts       # 努力値逆算
└── hooks/                      # カスタムフック（現在未使用）
```

## 3. 主要な問題点と改善案

### 3.1 コードの重複

#### 問題点
- `StatInput`コンポーネントがThunderForm.tsxとCustomMetagrossForm.tsxで重複定義
- フォームコンポーネントの構造がほぼ同一

#### 改善案
```typescript
// components/common/StatInput.tsx として共通化
// components/common/PokemonForm.tsx として汎用フォームを作成
```

### 3.2 責務の分離不足

#### 問題点
- `battle.ts`が550行と肥大化
- 状態管理、ターン処理、持ち物効果、状態異常処理が1ファイルに混在

#### 改善案
```
utils/battle/
├── index.ts           # エントリーポイント
├── turnOrder.ts       # ターン順決定ロジック
├── statusEffects.ts   # 状態異常処理
├── itemEffects.ts     # 持ち物効果
├── damagePhase.ts     # ダメージ処理フェーズ
└── battleState.ts     # バトル状態管理
```

### 3.3 テスタビリティの低さ

#### 問題点
- 巨大な関数による単体テストの困難さ
- 副作用のある処理とビジネスロジックの混在
- 乱数に依存した処理の再現性がない

#### 改善案

1. **乱数シードの固定化**
```typescript
// 乱数生成器のインターフェース化
interface RandomNumberGenerator {
  random(): number
  randomInt(min: number, max: number): number
}

// シード付き乱数生成器の実装
class SeededRandom implements RandomNumberGenerator {
  constructor(private seed: number) {}
  // ...
}

// バトルシミュレーターへの注入
const simulateBattle = (
  thunder: Thunder,
  metagross: Metagross,
  rng: RandomNumberGenerator = new SeededRandom(Date.now())
) => {
  // ...
}
```

2. **純粋関数への分解**
```typescript
// Before（副作用あり）
const battle = () => {
  let hp = 100
  hp -= calculateDamage()  // let使用
  return hp
}

// After（純粋関数）
const applyDamage = (currentHp: number, damage: number): number => 
  Math.max(0, currentHp - damage)

const battleTurn = (state: BattleState): BattleState => ({
  ...state,
  defenderHp: applyDamage(state.defenderHp, calculateDamage(state))
})
```

### 3.4 UI/UXの改善点

#### 問題点
1. **性格による能力値補正が非表示**
   - いじっぱり性格で攻撃↑特攻↓などの表示がない

2. **持ち物効果の詳細が不明瞭**
   - ツールチップのみで計算への影響が分かりにくい

3. **バトル詳細分析の不足**
   - 勝率のみで平均ターン数、勝因分析がない

#### 改善案
```typescript
// 性格効果の可視化
const NatureEffect = ({ nature }: { nature: Nature }) => {
  const { plus, minus } = getNatureModifiers(nature)
  return (
    <div className="flex gap-2">
      {plus && <span className="text-red-500">↑{plus}</span>}
      {minus && <span className="text-blue-500">↓{minus}</span>}
    </div>
  )
}

// バトル分析結果の追加
interface BattleAnalysis {
  winRate: number
  averageTurns: number
  winReasons: {
    byDamage: number
    byStruggle: number
    // ...
  }
}
```

### 3.5 関数型プログラミングへの移行

#### 問題点
- `let`の多用による状態の変更
- `for`ループによる命令型のコード
- 副作用のある処理の散在

#### 改善案

1. **let → const への置き換え**
```typescript
// Before
let total = 0
for (let i = 0; i < values.length; i++) {
  total += values[i]
}

// After
const total = values.reduce((sum, value) => sum + value, 0)
```

2. **for文の関数型への置き換え**
```typescript
// Before
const results = []
for (const item of items) {
  if (item.valid) {
    results.push(transform(item))
  }
}

// After
const results = items
  .filter(item => item.valid)
  .map(transform)
```

3. **状態更新の immutable 化**
```typescript
// Before
function updateBattleState(state) {
  state.hp -= damage  // 直接変更
  state.status = 'paralyzed'
  return state
}

// After
const updateBattleState = (state: BattleState, damage: number): BattleState => ({
  ...state,
  hp: state.hp - damage,
  status: 'paralyzed'
})
```

## 4. 実装優先順位

### Phase 1: 基盤整備（高優先度）
1. 共通コンポーネントの抽出
2. battle.tsのモジュール分割
3. 乱数シード機能の実装

### Phase 2: コード品質向上（中優先度）
1. let → const への全面的な置き換え
2. for文の関数型への変換
3. 単体テストの追加

### Phase 3: UI/UX改善（中優先度）
1. 性格効果の可視化
2. バトル詳細分析の追加
3. 持ち物効果の詳細表示

### Phase 4: パフォーマンス最適化（低優先度）
1. React.memoによる最適化
2. useMemoによる計算結果のキャッシュ
3. Web Workerの検討

## 5. 期待される効果

- **保守性向上**: モジュール分割により変更の影響範囲が明確化
- **テスタビリティ向上**: 純粋関数化により単体テストが容易に
- **再現性の確保**: シード固定により同じ条件で同じ結果を保証
- **開発効率向上**: 共通コンポーネントによる実装の高速化
- **ユーザビリティ向上**: UI改善により直感的な操作が可能に